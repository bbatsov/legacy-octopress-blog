---
layout: post
title: "Why Emacs?"
date: 2011-11-19 09:22
comments: true
categories:
- Emacs
---

## Prelude

{% blockquote Neal Stephenson, In the Beginning ... was the Command Line %}
If you are a professional writer – i.e., if someone else is getting paid to worry about how your words are formatted and printed – Emacs outshines all other editing software in approximately the same way that the noonday sun does the stars. It is not just bigger and brighter; it simply makes everything else vanish.
{% endblockquote %}

I'm an Emacs user and I'm proud of the fact. I know my reasons for
using it (and loving it) for many years now. But many people don't. I
often get asked by various people the same question - "Why should I
use Emacs? What makes it better than Eclipse/IntelliJ/vim/etc?".

While I wouldn't dare to claim that Emacs is better than all the IDEs
and competing editors I'll share here the things that I think are
making it great. But first...

<!--more-->

## A Text Editor in 2011 - Are You Mental or Something?

The simple fact is that the popularity of programmer's text editors is
not as high as it once was. With so many integrated development
environments flying around traditional text editors like Emacs and Vim
seems to have fallen out of grace with the mainstream
users/programmers and are mostly used by enthusiasts and old school
hackers these days.

For all the good things IDEs have brought us (smart auto-completion,
nice visual debuggers, semantic analysis of the source code, etc) they
have totally forgot about the most crucial part of software
development - it's mostly about editing text. And
all the IDEs I've used have extremely poor text editing capabilities
compared to likes of Emacs and vim. A very trivial example is the fact
that most IDEs don't even have keybindings optimized for touch typing
- they require you to move your hands often from the home row (such a waste)
and have mouse-centric UIs.

A programmer's editor might not have all the fancy bells and whistles
- but it has the thing that matters (should matter) the most - a
decent editing experience.

## The Road to Emacs

I was not always an Emacs user. And wasn't always an Unix user
either. My journey to computing started in the nineties when I was
doing some basic programming with Pascal in the Turbo Pascal
environment, notorious for its horrible editing features. Afterwards I
was drawn to the allure of C and C++ combined with Microsoft's Visual
Studio IDE. At first I felt it was like magic - so much of the source
code got generated by various wizards and I felt productive. Felt is
the key word here. At some
point, however, I noticed that all the wizard started to become
annoying - I already knew what they were about the generate and
sometimes I even had a better idea about the details of a particular
piece of code. Writing code manually at some point always becomes more
productive than clicking through wizards.

Then I've started my first professional gig in a company solely
devoted to FreeBSD, C and Perl. I had never used an Unix system before
and I captivated by the fact how much of its internals were open for the
user to tinker with and how many small tools were working together to
achieve a greater goal. I was also captivated by the editor that all my
colleagues in the company were using - vim. It was both simple and
profound - minimalistic UI, handy terminal support, plain-text
configuration, keybindings 100% optimized for touch typing and it had
so many cool editing features. I've used vim for a couple of years, but two
things about it always bothered me - dealing with many files was no
fun (at least back than - as far I know vim 7 has made some
improvements in the area) and vimscript (the extension language for
vim) simply sucked.

I had often heard rumors of a mythical editor so powerful and some
infinite in its capabilities that people were afraid to approach it. That
editor's name was Emacs. When I first started Emacs I had absolutely
no knowledge of Lisp what-so-ever, so dealing with it's configuration
in the beginning was a bit hard - I often copied some bits and piece
of code that I didn't fully understand and when there was an error
within some of those snippets, I was having a really hard time figuring
it out. Luckily for me I found a copy of
[Learning Emacs](http://www.amazon.com/Learning-Emacs-Third-Debra-Cameron/dp/0596006489/ref=sr_1_1?ie=UTF8&qid=1321689125&sr=8-1)
- a nice (but not great) book that gently guided me through the
  maelstrom of Emacs features. At first I was hardly efficient in
  Emacs, but my proficiency in it quickly grew.

I had a bit of luck that I switched jobs and went to work in a company
where Emacs had God-like status. All the cool devs there were using it
and they were also hardcore Lisp hackers. There I learned the true
power of Emacs, there I got hooked to Lisp and there I truly
understand what Emacs is about.

_Emacs is what you want it be. Emacs is power. But with great power,
comes great responsibility - the responsibility to think._

## Why Emacs?

{% img http://imgs.xkcd.com/comics/real_programmers.png %}

Enough small talk, let's talk business... Here's a brief overview of
the things that make Emacs special (at least to me).

#### Divine Editing Experience

You can easily navigate around text buffers, perform all sorts of
editing operations with a snap, without ever leaving the comfort of
the home row of your keyboard.

Emacs has support for some pretty fancy stuff like rectangular
editing, kill-ring (something like an internal clipboard history),
mark-ring (you can set points of interest in a buffer you can later
revisit), etc.

#### Everything is Possible

{% blockquote Unknown Emacs Hacker, The Collected Emacs Sayings %}
Emacs has got a mode for that!
{% endblockquote %}

Naturally every popular programming language is well supported under
Emacs (with the notable exception of PHP, which has once of the lamest
Emacs modes I've ever seen). Most not-so-popular programming
languages are well supported as well.

The quality and the features vary wildly though - some modes like
SLIME, cc-mode, js2-mode and cperl-mode are nothing short of magical
and others provide only basic highlighting and indentation support.

But this is only the tip of the iceberg - in Emacs you can easily
create beautifully typeset documents and books in LaTeX (with the help
of AUCTeX mode), charts with graphviz-mode, you can check your e-mail
with gnus (wanderlust and mew are other nice options), chat in IRC
with ERC, run a terminal session or write your next great blog
entry. And so many other things - there is even a coffee-mode that
allows you to control certain kinds of coffee machines from Emacs.

I happen to write all the articles on my site in Emacs and I publish
them to github pages using the excellent magit (git integration for
Emacs).

No matter what the task at hand is - you can rely on Emacs's superb
editing capabilities.

#### Emacs is Extensible

The GNU Emacs manual describes Emacs as _the extensible, customizable,
self-documenting, real-time display editor_. And with a good reason -
it's extremely easy to add new features to Emacs, due to its
integrated Emacs Lisp interpreter.

While there are some core things in Emacs, written in C for
efficiency's sake, almost all the great modes and magic commands are
written in a dialect of Lisp, called Emacs Lisp (that is somewhat
reminiscent of Common Lisp, albeit lacking many of its features).

What this means is that you get the dynamic nature of Lisp development
for all of your Emacs extensions - you can write a small bit of Emacs
Lisp code anywhere, eval it and run it right away. There are no tedious
compilations steps or huge interfaces that have to be
implemented. There is virtually no ceremony. For
instance:

``` cl
(defun prelude-google ()
  "Googles a query or region if any."
  (interactive)
  (browse-url
   (concat
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
    (if mark-active
        (buffer-substring (region-beginning) (region-end))
      (read-string "Google: ")))))
```

This simple bit of code adds to Emacs the ability to invoke Google
queries from it (with the help of your favorite browser). After
evaluating this code in Emacs you can simply type `M-x prelude-google`
and this new command will be at your disposal.

In Emacs it's easy to create modes that support programming languages,
provide functionality such as IM and email checking, etc.

#### Emacs Integrates Well with Lots of External Tools

Running a shell from Emacs is easy - `M-x shell-mode`. Running a
terminal emulator in Emacs is just as easy - `M-x ansi-term`. And
there is even a shell written in Emacs Lisp, called `eshell`, that you
can use no matter what the underlying operating system is.

You need a file browser for Emacs - we have plenty! `Dired` is the
tried and try option, but there are "more modern" solutions such as
emacs-nav.

Version Control integration? You bet! CVS, SVN, bazaar, git, mercurial
- everything is supported out of the box!

You want to invoke a shell commands on the side? Nothing is easier.

You want to invoke make/rake/whatever from Emacs? Done and done.

You can even use Emacs as a process manager (`M-x proced`).

#### Emacs Doesn't Make You Repeat Yourself

Emacs supports everything in the playbook on DRY (Don't Repeat
Yourself). Command repetition, prefix command arguments, keyboard
macros, Emacs Lisp functions, etc. I use them all - and I love them all.

#### It's Easy to Share an Editing Session Between GUI and Terminal

While many people prefer to do all their editing in the terminal or in
a GUI application - I don't. I spend most of my time in a GUI Emacs
frame, but from time to time I occasionally fire Emacs from the
terminal to do some quick edit.

Emacs doesn't start up as fast as vim, so I would be pretty pissed if
I had to wait for it to load every time. Luckily it has a feature
called Emacs daemon, which allows you to start a headless emacs server to
which you can afterwards connect to from both GUI and terminal
clients:

``` bash
$ emacs --daemon
$ emacsclient -c
$ emacsclient -t
```

`emacsclient -c` opens up a new Emacs GUI frame, while `emacsclient
-t` fires up a new terminal frame. And the best part - all the buffers
currently opened can be shared between as many clients as it pleases
you.

You can push the idea a notch further and connect to an Emacs daemon
running on a remote machine.

#### Emacs is Modern

Contrary to what some people say about Emacs - it is a pretty modern piece of
software. On *BSD and Linux the GUI is implemented in GTK2/3, on OS X
it's using Cocoa, and on Windows - it's naturally using WinAPI. Emacs
integrates well with the OSes it runs on - for instance the OS's
clipboard is integrated well with Emacs's kill-ring out of the
box. Things like the Trash are also covered.

Emacs supports TTF fonts, has a built-in semantic code parser (called
Semantic), features a package manager that allows you retrieve Emacs
packages (extensions) from remote locations automatically (think of a
tool similar to `apt-get` or `brew` for Emacs packages).

#### Emacs is Constantly Evolving

Emacs has literally evolved before my eyes - when I started using it 7
years ago there was no support for truetype fonts, no Emacs daemon, no
built-in Semantic, no GTK2 UI, no package manager, etc. I cannot dare
to imagine what exciting changes are about to come...

#### Other Prominent Tools Use Emacs's keybindings

Most shells (`bash`, `zsh`, etc) use Emacs keybindings by default. Most of
the Emacs keybindings are the same as those found in the readline
library. Apple's Cocoa toolkit uses Emacs keybindings as well - I
guess this is one of the reasons why so many Emacs users love OSX.

## Emacs vs the World

#### Emacs vs vim

Emacs vs vim. The most epic battle of them all. More epic than Linux
vs Windows and Barcelona vs Real Madrid combined... This, however, is
no flame post and I'll not be bashing vim here. I'll just mention my
brief (and highly personal take on the subject).

For me Emacs has these advantages over vim:

* it has better _default_ extension language. I haven't wrote any vim
  extension in Python/Ruby, but I can imagine it's a much more
  pleasant process than using vimscript.
* it's modeless - switching constantly between command-mode and
editing mode is not very annoying, but I do prefer Emacs's way
* it has better integration with external systems
* it has better support for the things that matter to me
* it has a built-in package manager
* it has better infrastructure for editing many files in the same session

On the other side vim excels in a few areas for me:

* nicer navigation
* much smaller core and much faster to load
* very simple initial config
* it has a more stylish icon than Emacs ;-)

#### Emacs vs IDEs

Emacs is considered by many to be the prototype of modern IDEs, but
it's quite different from most of them. IDEs main strengths are good
refactoring support, semantic code analysis, integrated GUI debuggers
and GUI design tools, precise auto-completions and good integration
with external systems such as version control and issue tracking.

IDEs main weakness are their poor editors and their dependency to the
mouse and an X environment in general. IDEs in general are not
particularly resource efficient either, but I guess that this matters
less and less as computers grow more and more powerful. Many people
(me included) have tried to use Emacs or vim keybindings in a IDE, but
it's a pointless quest - without all of the features of Emacs/vim a
few keybindings are mostly useless.

For me the true problems of IDEs lies somewhere totally else and it's
less mentioned. The IDEs impair your thinking by thinking instead of
you. I've seen people generate a lot of code with IDEs without ever
questioning its workings or quality. When you produce everything
manually you're much more likely to contemplate on its quality and to
consider ways to make it more concise and more elegant.

This, of course, is highly subjective - I mean no offense to IDE users
in general. I do, however, know very well the APIs I've programmed in
Emacs and remember less about APIs I've programmed in IntelliJ (for instance).

## Emacs is not Perfect

Emacs is not perfect, of course. There a lot of things Emacs users
would still like to see.

#### Replace Emacs Lisp with Scheme or Common Lisp

While Emacs Lisp has served Emacs well so far, it's far from the best
Lisp dialects out there. While I'd personally like to see it swapped
for Common Lisp I guess this is never going to happen. There was,
however, a rumor last year that there is a long term plan to replace
Emacs Lisp with Scheme (GNU Guile to be precise). I have absolutely no
idea how much of a possibility that is - but I do know that we could
use a bit more powerful and a bit more modern extension language.

#### Improvements to the GUI

While the GUIs in recent Emacs version were much improved there is
still much to be desired.

For instance - on OSX it would be nice if Emacs used Lion style
scrollbars and had support for the full-screen app mode. On OSX there
are some strange Cocoa bugs as well - like linum-mode looking
corrupted, etc.

I guess that currently Emacs's GTK version has the nicest GUI of them
all, but it would good of the Windows and OSX port got some more love.

#### Multi-threading

Emacs is a single-threaded app and this is problematic, since tasks
that block that one thread for an extended period of time (like email
checking) tamper with Emacs's responsiveness. Multi-threading support
is certainly coming to Emacs, but I cannot speculate with a
time-frame. I guess it will be part of Emacs 25 and we're least a
few years away from it (Emacs 24 is still not released).

#### Integrate Semantic tightly into Emacs

Currently most programming modes in Emacs are implementing syntax
highlighting just by searching for regexp patterns. This is
notoriously fragile approach - especially in languages like Ruby, that
have a very complex grammar. Basing syntax highlighting on a semantic
analysis of the code would be much more robust. Not to mention that it
will open the gates for much more advanced features in Emacs
programming modes. I've read somewhere that such tight integration
with Semantic is truly planned. We'll just have to wait and see (and
why not even help?). Of course there is the matter with backward compatibility...

## Getting Started with Emacs

OK, I've told you some interesting things and I've piqued your
interest in Emacs. Now you're probably wondering how can you get
started with it. Knowing what I know now - I don't recommend my
personal chaotic approach to mastering Emacs. Here's a few tips to get
you started.

#### Obtain a copy of Emacs 24

Emacs 23 is old news, Emacs 24 is the future. Take a look at my post
[Getting Started with Emacs 24](/articles/2011/10/09/getting-started-with-emacs-24/) for more details.

#### Obtain a Decent Initial Config

The default configuration sucks. Luckily there is [Emacs Prelude](https://github.com/bbatsov/emacs-prelude) -
Emacs 24 configuration that doesn't suck. I highly recommend you to
use Prelude as your initial Emacs config. Studying its source will
give you a bit of an insight into Emacs Lisp programming

#### Read & Practice

* first step - run the built-in Emacs tutorial - `C-h t`
* second step - watch the excellent screencast [Meet Emacs](https://peepcode.com/products/meet-emacs)
* third step - visit [Mastering Emacs](http://www.masteringemacs.org)
* forth step - read the official Emacs Manual - `C-h r`
* fifth step - use Emacs day and night for all your work

## Epilogue

{% blockquote Eric S. Raymond, The Art of UNIX Programming %}
Emacs is undoubtedly the most powerful programmer's editor in existence. It's a big, feature-laden program with a great deal of flexibility and customizability. As we observed in the Chapter 14 section on Emacs Lisp, Emacs has an entire programming language inside it that can be used to write arbitrarily powerful editor functions.
{% endblockquote %}

Should you give Emacs a shot? I have absolutely no idea... If you
found something in my post intriguing - I guess you should. If it was
to you like the ramblings of mad fanatic with no connection to the real
world - probably not.

I truly believe that anyone could gain something positive by spending
some time with Emacs and exploring its vision and culture. I guess
that in the it all boils down to whether you believe me...
